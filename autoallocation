views.py
class Rules(APIView):
    def post(self, request):
        data = request.data
        entity, airport = get_entity_airport(request)
        try:
            rule_id = data.get('rule_id')
            rule_data = data.get("rulemaster", {})
            condition_list = data.get('condition', [])
            action_list = data.get('action', [])

            if rule_id:
                rulemaster = AutoAllocationRuleMaster.objects.get(rule_id=rule_id)
            else:
                department_id = GroundSupportEquipmentTypes.objects.filter(entity=entity, airport=airport,equipment_code=rule_data.get('task_code')).first().department_id
                rulemaster = AutoAllocationRuleMaster.objects.create(
                    rule_name=rule_data.get('rule_name'),
                    applies_to=rule_data.get('applies_to'),
                    task_code=rule_data.get('task_code'),
                    action_type=rule_data.get('action_type'),
                    start_date=rule_data.get('start_date'),
                    end_date=rule_data.get('end_date'),
                    created_by=rule_data.get('created_by'),
                    is_active = True,
                    department_id = department_id,
                    priority=rule_data.get('priority', 1)
                )

            created_condition = []
            for condition_data in condition_list:
                createcondition = AutoAllocationRuleCondition.objects.create(
                    rule_id=rulemaster,
                    group_id=condition_data.get('group_id', 1),
                    parameter=condition_data.get('parameter'),
                    operator=condition_data.get('operator'),
                    value=condition_data.get('value'),
                    logical_operator=condition_data.get('logical_operator')
                )
                created_condition.append(f"{createcondition.id} - {createcondition.parameter} ")

            created_action = []
            for action_data in action_list:
                createaction = AutoAllocationRuleAction.objects.create(
                    rule_id=rulemaster,
                    action_param=action_data.get('action_param'),
                    created_by=action_data.get('created_by'),
                    value=action_data.get('value', '')
                )
                created_action.append(f"{createaction.id} - {createaction.action_param}")

            return Response({
                "message": f"Created rules: {rulemaster.rule_id} - {rulemaster.rule_name}, "
                           f"conditions: {created_condition} "
                           f"and action: {created_action} successfully."
            }, status=status.HTTP_201_CREATED)

        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def patch(self, request):
        data = request.data
        try:
            rule_data = data.get('rulemaster', {})
            condition_list = data.get('condition', [])
            action_list = data.get('action', [])

            rulemaster = AutoAllocationRuleMaster.objects.get(rule_id=rule_data.get('rule_id'))

            with transaction.atomic():

                for field, value in rule_data.items():
                    if field != "rule_id" and hasattr(rulemaster, field):
                        setattr(rulemaster, field, value)
                rulemaster.save()

                updated_conditions = []
                for condition_data in condition_list:
                    condition_id = condition_data.get('condition_id')
                    if condition_id:
                        condition = AutoAllocationRuleCondition.objects.get(id=condition_id, rule_id=rulemaster)
                        for field, value in condition_data.items():
                            if field != "condition_id" and hasattr(condition, field):
                                setattr(condition, field, value)
                        condition.save()
                        updated_conditions.append(f"{condition.id} - {condition.parameter}")

                updated_actions = []
                for action_data in action_list:
                    action_id = action_data.get('action_id')
                    if action_id:
                        action = AutoAllocationRuleAction.objects.get(id=action_id, rule_id=rulemaster)
                        for field, value in action_data.items():
                            if field != "action_id" and hasattr(action, field):
                                setattr(action, field, value)
                        action.save()
                        updated_actions.append(f"{action.id} - {action.action_param} ")

            return Response({
                "message": f"updated rules: {rulemaster.rule_id} - {rulemaster.rule_name}, "
                           f"conditions: {updated_conditions} "
                           f"and action: {updated_actions} successfully."}, status=status.HTTP_200_OK)

        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def get(self, request):
        rule_id = request.query_params.get('rule_id')
        entity, airport = get_entity_airport(request)
        if not entity or not airport:
            return Response({"error": "User entity or airport not found"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            rulemasters = AutoAllocationRuleMaster.objects.filter(is_active=True).prefetch_related('conditions', 'actions')
            if rule_id:
                rulemasters = rulemasters.filter(rule_id=rule_id)
            data_rows = []
            for rulemaster in rulemasters:
                rule_data = {
                    "rule_id": rulemaster.rule_id,
                    "rule_name": rulemaster.rule_name,
                    "applies_to": rulemaster.applies_to,
                    "task_code": rulemaster.task_code,
                    "action_type": rulemaster.action_type,
                    "start_date": rulemaster.start_date,
                    "end_date": rulemaster.end_date,
                    "created_by": rulemaster.created_by,
                    "updated_by": rulemaster.updated_by,
                    "department_id": rulemaster.department_id,
                    "priority": rulemaster.priority,
                }

                conditions_data = [
                    {
                        "group_id": condition.group_id,
                        "parameter": condition.parameter,
                        "operator": condition.operator,
                        "value": condition.value,
                        "logical_operator": condition.logical_operator
                    }
                    for condition in rulemaster.conditions.all()
                ]
                actions_data = [
                    {
                        "action_param": action.action_param,
                        "created_by": action.created_by,
                        "updated_by": getattr(action, 'updated_by', None),
                        "value": action.value
                    }
                    for action in rulemaster.actions.all()
                ]
                data_rows.append([rule_data, conditions_data, actions_data])

            config_data = EntityAirports.objects.filter(entity=entity, airport=airport).values_list('config',flat=True).first()
            metadeta = json.loads(config_data) if config_data else {}
            rule_json = metadeta.get("rule_config", {})
            result = {
                "columns": ["Rules", "Conditions", "Actions"],
                "data": data_rows,
                "meta": rule_json
            }
            return Response(result, status=status.HTTP_200_OK)

        except AutoAllocationRuleMaster.DoesNotExist:
            return Response({"error": "Rule not found"}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    def delete(self, request):
        data = request.data
        try:
            rule_id = data.get('rule_id')
            condition_ids = data.get('condition_id')
            action_ids = data.get('action_id')

            if not rule_id:
                return Response({"error": "Missing rule_id"}, status=status.HTTP_400_BAD_REQUEST)

            rulemaster = AutoAllocationRuleMaster.objects.get(rule_id=rule_id)

            deleted_conditions = []
            deleted_actions = []

            if condition_ids:
                conditions = AutoAllocationRuleCondition.objects.filter(id__in=condition_ids, rule_id=rule_id)
                deleted_conditions = [f"{cond.id} - {cond.parameter} " for cond in conditions]
                conditions.delete()

            if action_ids:
                actions = AutoAllocationRuleAction.objects.filter(id__in=action_ids, rule_id=rule_id)
                deleted_actions = [f"{act.id} - {act.action_param}" for act in actions]
                actions.delete()

            if not condition_ids and not action_ids:
                rulemaster.is_active = False
                rulemaster.save()
                all_conditions = AutoAllocationRuleCondition.objects.filter(rule_id=rulemaster)
                all_actions = AutoAllocationRuleAction.objects.filter(rule_id=rulemaster)
                deleted_conditions = [f"{cond.id} - {cond.parameter}" for cond in all_conditions]
                deleted_actions = [f"{act.id} - {act.action_param}" for act in all_actions]
                all_conditions.delete()
                all_actions.delete()
                return Response({
                    "message": f"rules -  {rule_id} deactivated. All related conditions and actions deleted.",
                    "conditions_deleted": deleted_conditions,
                    "actions_deleted": deleted_actions
                }, status=status.HTTP_200_OK)

            return Response({"message":f"deleted rules: {rulemaster.rule_id} - {rulemaster.rule_name}, "
                           f"conditions: {deleted_conditions} "
                           f"and action: {deleted_actions} successfully." }, status=status.HTTP_200_OK)

        except AutoAllocationRuleMaster.DoesNotExist:
            return Response({"error": "Rulemaster not found"}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

models.py


from django.db import models


class AutoAllocationRuleMaster(models.Model):
    rule_id = models.AutoField(db_column="rule_id",primary_key=True)
    rule_name = models.CharField(max_length=255,db_column='rule_name')
    applies_to = models.CharField(max_length=255,db_column='applies_to')
    task_code = models.CharField(max_length=255,db_column='task_code')
    action_type = models.CharField(max_length=50,db_column='action_type')
    start_date = models.DateField()
    end_date = models.DateField()
    created_by = models.CharField(max_length=50,db_column='created_by')
    updated_by = models.CharField(max_length=50,db_column='updated_by')
    is_active = models.BooleanField(default=True)
    department_id = models.IntegerField(db_column='department_id')
    priority = models.IntegerField(default=1,db_column='priority')


    class Meta:
        db_table = 'AutoAllocationRuleMaster'


class AutoAllocationRuleCondition(models.Model):
    rule_id = models.ForeignKey(AutoAllocationRuleMaster, on_delete=models.CASCADE,db_column='rule_id',related_name='conditions')
    group_id = models.IntegerField(default=1,db_column='group_id')
    parameter = models.CharField(max_length=100,db_column='parameter')
    operator = models.CharField(max_length=20,db_column='operator')
    value = models.CharField(max_length=100,db_column='value')
    logical_operator = models.CharField(max_length=20,db_column='logical_operator')



    class Meta:
        db_table = 'AutoAllocationRuleConditions'


class AutoAllocationRuleAction(models.Model):
    rule_id = models.ForeignKey(AutoAllocationRuleMaster, on_delete=models.CASCADE,db_column='rule_id',related_name='actions')
    action_param = models.CharField(max_length=100,db_column='action_param')
    value = models.CharField(max_length=255, blank=True, null=True)
    created_by = models.CharField(max_length=50,db_column='created_by')
    updated_by = models.CharField(max_length=50,db_column='updated_by')


    class Meta:
        db_table = 'AutoAllocationRuleActions'
urls.py

from django.urls import re_path
from .views import (DispatcherAllocation, DispatcherFlights, AllocationReport, AutoAllocationTrigger,
                    AutoAllocationLogs,
                    AutoAllocationFlightSummary, AutoAllocationUtilizationSummary, PeakHourSummary,
                    AutoAllocationResourceSummary, SystemUpdateAllocation,Rules)

urlpatterns = [
    re_path(r'^allocations/?$', DispatcherAllocation.as_view(), name='allocations'),
    re_path(r'^flights/?$', DispatcherFlights.as_view(), name='flights'),
    re_path(r'^auto_allocation_report/?$', AllocationReport.as_view(), name='allocation_report'),
    re_path(r'^auto-allocation/?$', AutoAllocationTrigger.as_view()),
    re_path(r'^allocation-logs/?$', AutoAllocationLogs.as_view()),
    re_path(r'^allocation-flight-logs/?$', AutoAllocationFlightSummary.as_view()),
    re_path(r'^allocation-resource-logs/?$', AutoAllocationResourceSummary.as_view()),
    re_path(r'^allocation_summary_utilization/?$', AutoAllocationUtilizationSummary.as_view()),
    re_path(r'^peak_hour_chart/?$', PeakHourSummary.as_view()),
    re_path(r'^system_update_allocation/?$', SystemUpdateAllocation.as_view()),
    re_path(r'^auto-allocation_rules/?$',Rules.as_view()),
]
